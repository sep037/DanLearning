# 목차

1. 네트워크 계층
    1. OSI 계층
    2. TCP/IP 4계층
2. TCP와 UDP
    1. TCP
    2. TCP 핸드셰이킹
    3. TCP 제어 방법
    4. UDP
    5. UDP의 오류 검출
3. HTTP
    1. HTTP
    2. HTTPS
    3. 웹 페이지 접속 과정
4. REST
    1. REST란?
    2. REST API
    3. HTTP 메서드
    

---

## 1. 네트워크 계층

<aside>
💡 네트워크에서의 다양한 기기 간 통신을 위해 약속된 구조

1. **OSI 7계층** - 네트워크를 개념적으로 나눔
2. **TCP/IP 4계층** - 실제 인터넷 통신에 사용됨
</aside>

### (1) OSI 7계층

- 네트워크 통신이 이뤄지는 과정을 7단계로 나눈 네트워크 표준 모델
- 데이터의 송수신 간략한 흐름
    
    
    1. `데이터 송신부` : 높은 계층 → 낮은 계층으로 데이터 전달 
    2. 데이터 수신부 가장 낮은 계층 도달
    3. `데이터 수신부` : 낮은 계층 → 높은 계층으로 데이터 전달
- 계층
    
    <aside>
    💡 데이터 송신시 아래 순서로 보냄
    데이터 수신시 역순으로 받음
    
    - 7계층 - 응용 계층
        - HTTP, FTP 등의 프로토콜을 응용 프로그램의 UI를 통해 제공
    - 6계층 - 표현 계층
        - 데이터를 표준화된 형식으로 변경함
    - 5계층 - 세션 계층
        - 세션의 유지 및 해제 등 응용 프로그램 간 통신 제어와 동기화를 함
    - 4계층 - 전송 계층
        - 신뢰성 있는 데이터를 전달하기위한 계층
        - TCP, UDP 같은 전송 방식과 포트 번호 등을 결정
    - 3계층 - 네트워크 계층
        - 데이터를 송신부에서 수신부까지 보내기 위한 최적 경로를 선택하는 라우팅을 수행
            - 라우트: 이때 선택한 최적 경로
            - 라우터: 네트워크 계층의 장비
    - 2계층 - 데이터 링크 계층
        - 데이터 흐름을 관리하며 데이터의 오류 검출 및 복구 등을 수행
        - 데이터 링크 계층의 장비
            - 브리지 (bridge)
            - 스위치
            - 이더넷
    - 1계층 - 물리 계층
        - 데이터를 비트 단위의 0과 1로 변환한 후 장비를 사용해 전송하거나 전기 신호를 데이터로 복원
        - 물리계층의 장비
            - 리피터 (repeater)
            - 허브 (hub)
    </aside>
    
    - 각 계층은 독립적
    - 데이터 송신시 각 계층에서 필요한 정보 추가해 데이터 가공
        - `데이터 캡슐화` : 제어 정보를 담은 헤더나 트레일러가 붙음 ← 수신부의 같은 계층에서 데이터 호환성 ⤴️ & 오류 영향 ⤵️
            - 헤더: 데이터 앞에 붙음
            - 트레일러: 데이터 뒤에 붙음
- 데이터 송수신 과정
    1. 송신부에서 7계층 → 1계층 거쳐 데이터 캡슐화
    2. 데이터 캡슐화 결과물을 수신부가 1계층 → 7계층 데이터 역캡슐화
        - 받은 데이터에서 헤더와 트레일러 분석해 제거
        - 이때, 각 계층은 필요한 제어 정보를 얻음
    

    
- `프로토콜`: 통신 규약 (데이터를 송수신하기 위해 정한 규칙)

### (2) TCP/IP 4계층

- 인터넷에서 데이터를 주고받기 위한 네트워크 프로토콜
- TCP/IP에 맞춰 OSI 7계층을 단순화한 것
    - OSI 7계층 = 네트워크 통신 표준
    - TCP (Transmission Control Protocol, 전송 제어 프로토콜): 패킷의 전달 여부와 전송 순서를 보장하는 통신 방식
        - 패킷
            - 네트워크에서 주고받는 데이터를 작게 분할한 단위
            - 데이터의 송신 주소, 수신 주소 등의 정보 포함 → 데이터를 목적지에 제대로 전달 가능
    - IP (Internet Protocol, 인터넷 프로토콜): 패킷을 빠르게 보내기 위한 통신 방식
- TCP/IP 기반 프로토콜
    - HTTP (대표적)

<aside>
💡 TCP/IP 4계층

- 4계층 - 응용 계층
    - 사용자와 소프트웨어를 연결해 주는 계층
    - HTTP, HTTPS, DNS 등의 프로토콜이 작동함
    - 데이터 단위: 메세지
- 3계층 - 전송 계층
    - 데이터의 신뢰성을 보장함
    - 포트 번호로 데이터를 적절한 응용 프로그램에 전달
    - 전송 계층의 프로토콜
        - TCP, UDP
    - 데이터 단위: 세그먼트
- 2계층 - 인터넷 계층
    - 데이터를 최종 목적지까지 도달할 수 있게 하는 계층
    - 대표적인 프로토콜
        - IP
    - 전송 계층으로부터 받은 데이터에 헤더를 붙여 캡슐화함
        
        ⇒ 패킷 또는 데이터그램이라 불림
        
- 1계층 - 네트워크 인터페이스 계층
    - 네트워크 접근 계층이라고도 함
    - 데이터를 전기 신호로 변환 후 MAC 주소를 사용해 기기에 데이터를 전달
        - MAC 주소 (Media Access Control address) : 48비트로 구성된 하드웨어 고유의 주소로, 네트워크 인터페이스 계층에서 사용
    - 대표적인 프로토콜
        - 이더넷, Wi-Fi
    - 데이터 단위: 프레임
</aside>

### (+) 추가 개념

- IP 주소
    - 컴퓨터 또는 네트워크 장치를 식별하기 위한 값
    - IPv4에서의 주소값 형태
        - xxx.xxx.xxx.xxx
            - 8자리 2진수 4개를 10진수로 표현한 것
    - 네트워크부와 호스트부로 나뉨
        - 네트워크부 (**xxx.xxx.xxx**.xxx): 해당 주소가 어떠한 네트워크에 속해 있는지 구분하는 값
        - 호스트부 (xxx.xxx.xxx.**xxx**): 해당 네트워크에서 어떠한 기기인지를 나타내는 값
- 서브넷 마스크 (subnet mask)
    - 네트워크부와 호스트부 구분시 사용
    - IP와 동일한 구조로 구성
        - 255.255.255.0
            
            = 11111111.11111111.11111111.00000000
            
    - 연속적인 1과 0으로 구성되어 있어 IP주소와 and 연산시 네트워크부와 호스트부를 알아낼 수 있음
        
        

---

## 2. TCP와 UDP

- 전송 계층에서 사용하는 대표적인 프로토콜

### (1) TCP

- 전송 계층에 해당하는 네트워크 프로토콜로, 연결형 서비스를 지원하고 데이터의 신뢰성을 보장
- 특징
    - 송신부와 수신부의 연결을 확인하는 연결형 서비스임
    - 패킷 교환 방식 = 가상 회선 방식 (패킷이 전달되는 회선이 정해져 있음)
        - (+) 패킷 교환 방식이란?
            - 가장 많이 사용하는 데이터 통신 방식
            - 종류
                1. 가상 회선을 이용한 방식: 데이터를 주고 받기 전에 패킷을 전송할 경로인 가상회선을 설정해서 모든 패킷을 같은 경로로 전송 (ex. TCP)
                2. 데이터그램을 이용한 방식
                    1. 패킷마다 최적의 경로로 전송되는 방식
                    2. 송신부에서 보낸 패킷의 순서와 수신부에 도착하는 패킷의 순서가 다를 수 있음 (ex. UDP)
    - 패킷의 전송 순서 보장
    - 패킷의 수신 여부 확인
    - 송신부와 수신부는 1:1 통신을 함
    - 신뢰성이 높음 ← 데이터 무손실 보장
    - 데이터의 송수신 속도 느림

### (2) TCP 핸드셰이킹

- 연결형 서비스를 지원하기 위해 송신부와 수신부 연결하는 과정 거침
    - 연결 시작시 3-way 핸드셰이킹
    - 연결 종료시 4-way 핸드셰이킹
- 핸드셰이킹 과정에서는 `플래그 값` 주고 받음 ← 송신부와 수신부 간 연결을 제어 및 관리
    - **SYN :** 연결 생성시 사용, Synchronization(동기화)의 약자
    - **FIN :** 연결을 끊을 때 사용, Finish(종료)의 약자
    - **ACK :** 데이터를 전송하면 수신자가 받았음을 알려줄 때 사용, ****Acknowledgement(승인)의 약자
    - RST : 연결을 재설정할 때 사용, Reset(초기화)의 약자
    - PSH : 빠른 응답이 필요한 데이터를 응용 계층으로 즉시 전송할 때 사용, Push(밀다)의 약자
    - URG : 다른 데이터보다 우선순위가 높은 데이터를 전송할 때 사용, Urgent(긴급)의 약자
- **3-way 핸드셰이킹**
    - 데이터를 본격적으로 주고받기 전에 상대방 컴퓨터와 세션을 수립하는 과정
    - 데이터의 정확한 전달을 위해 필요한 절차
    - 데이터의 송신자와 수신자 모두 데이터를 주고받을 준비가 되었음을 보장
    - 과정
        1. 송신부 -`SYN(N)`→ 수신부
            1. 송신부가 수신부와 연결하기 위해 임의의 숫자 N과 함께 SYN 메시지를 보냄
            2. **송신부**는 수신부로부터 응답이 오기 전까지 **SYN_SENT 상태**가 됨
        2. 송신부 ←`ACK(N+1) + SYN(M)`- 수신부
            1. 수신부가 송신부로부터 SYN 메시지를 받으면 연결 요청을 수락하는 의미인 ACK 메시지에 송신부로부터 받은 N에 1을 더한 값을 함께 보냄
            2. 수신부에서도 송신부와의 연결을 확인하기 위해 SYN 메시지에 임의의 숫자 M을 함께 보낸 후 송신부의 응답을 기다림
            3. 이때 **수신부는 SYN_RECEIVED 상태**가 됨
        3. 송신부 -`ACK(M+1)`→ 수신부
            1. **송신부**가 수신부로부터 ACK + SYN 메시지를 받으면 연결이 성립되었다는 의미인 **ESTABLISHED 상태**가 됨
            2. 메시지에 대한 응답으로 ACK 메시지와 수신부로부터 받은 M에 1을 더한 값을 함께 보내는데 ACK 메시지에 송신부에서 전송하려는 데이터가 포함될 수 있음
            3. 송신부로부터 ACK메시지를 받으면 **수신부는 ESTABLISHED 상태**가 됨
- **4-way 핸드셰이킹**
    - TCP 연결을 해제할 때 이뤄지는 과정
    - 과정
        1. 송신부 -`FIN`→ 수신부
            1. 송신부가 수신부와의 연결을 종료하려고 FIN 메시지를 보냄
            2. 이때 **송신부는 FIN_WAIT1 상태**가 됨
        2. 송신부 ←`ACK`- 수신부
            1. 수신부가 송신부로부터 FIN 메시지를 받으면 이에 대한 응답으로 ACK 메시지를 보냄
            2. 이때 **수신부는 CLOSE_WAIT 상태**가 됨
            3. 수신부는 메시지를 보낸 후 연결을 종료하기 위한 작업을 함 (ex. 앱 종료)
            4. **송신부**에서는 수신부에서 보낸 ACK 메시지를 받고 **FIN_WAIT2 상태**가 됨
        3. 송신부 ←`FIN`- 수신부
            1. **수신부**에서 연결을 종료할 준비가 끝나면 송신부에 FIN 메시지를 보내고 **LAST_WAIT 상태**가 됨
        4. 송신부 -`ACK`→ 수신부
            1. **송신부는** 서버로부터 받은 FIN 메시지에 응답하기 위해 ACK 메시지를 보내고 **TIME_WAIT 상태**가 됨
            2. 일정시간이 지나면 **CLOSED 상태**가 됨
                - FIN 메시지 전에 보낸 패킷이 FIN 메시지 수신보다 지연되어 발생하는 패킷 유실에 대비
                - 수신부에 ACK 메시지가 제대로 전달되지 않아 연결 해제가 이뤄지지 않는 경우도 대비
            3. **수신부는** 송신부로부터 ACK 메시지를 받고 **CLOSED 상태**가 됨
- (+) 추가 개념
    - 세션 연결시 이를 유지하기 위해 일정시간 경과 후 `TCP Keep Alive 패킷` 던져 연결 유지 상태 확인 가능
        - TCP Keep Alive 패킷
            - 연결 유지 원하는 쪽에 보냄
            - 패킷에 대한 응답 수신 O → 시간 처음부터 다시 측정
            - 패킷에 대한 응답 수신 X → 연결 종료
        - 장점
            - 동일한 송신부로부터 재요청이 오는 경우 불필요한 3-way 핸드셰이킹 방지
            - FIN 메시지를 받지 못한 경우에 발생할 수 있는 불필요한 연결 (좀비 커넥션) 방지

### (3) TCP 제어 방법

- TCP의 데이터 신뢰성을 보장하기 위한 제어 방법
    - 흐름 제어
    - 혼잡 제어
    - 오류 제어
- **흐름 제어**
    - 데이터 **송신부와 수신부에서 데이터 처리 속도의 차이** 때문에 생기는 데이터 손실을 방지하는 방법
    - 방식
        - 정지-대기 (stop-wait)
            - 송신부에서 데이터를 보낸 후 수신부로부터 ACK 메시지를 받을 때까지 다음 데이터를 보내지 않고 기다리는 방식
            - 송신부에서 패킷을 보내고 일정 시간 동안 수신부로부터 ACK 메시지를 받지 못하면 패킷을 재전송
            - 장점: 간단함
            - 단점: 이전 메시지에 대한 응답을 받아야만 다음 메시지를 보낼 수 있어서 시간 면에서 비효율적
        - 슬라이딩 윈도우
            - 송신부에서 데이터의 수신 여부(ACK)를 확인하지 않고 수신부에서 설정한 윈도우 크기만큼 데이터를 연속적으로 보낼 수 있게 해서 데이터 흐름을 동적으로 제어하는 방식
                - 윈도우 크기
                    - 응답받지 않고도 보낼 수 있는 데이터의 최대 개수
                    - 3-way 핸드셰이킹 과정에서 정해짐
            - 윈도우 크기 N ⇒ ACK 메시지를 받지 않은 상태에서 N개 데이터를 보낼 수 있음
                - n번 데이터 ~ n+N-1번 데이터까지 송신한 상태에서 n번 데이터에 대해 ACK 메시질ㄹ 받으면 n+N번 데이터를 보낼 수 있게 됨
                - n+1번부터 n+N-1번 데이터에 대한 ACK 메시지를 받지 않아도 다음 데이터를 보낼 수 있음
        - 수신여부와 상관없이 일정 크기의 데이터를 연속적으로 보냄
            
            ⇒ ACK 메시지를 받아야만 다음 메시지 보낼 수 있는 정지-대기 방식의 단점 보완
            
- **혼잡 제어**
    - **송신부의 데이터 전달 속도와 네트워크 속도 차이**로 데이터 손실이 발생하는 것을 방지하기 위한 방법
    - 혼잡: 네트워크에 패킷 수가 과도하게 증가하는 증상
        - 혼잡 발생 → 네트워크 패킷 쌓이면서 일정 시간 응답 받지 못함 ⇒ 송신부에서는 메시지 전송에 실패했다고 판단해 수신부에 패킷을 재전송함 ⇒ 혼잡 가중 → 악순환 야기
        
        💡 TCP : 혼잡 윈도우 크기 조절 → 혼잡 대응
        
    - 방식
        - AIMD (Additivie Increase Multiplicative Decrease)
            - 데이터 전달시 합 증가 (additive increse) 방식으로 혼잡 윈도우의 크기를 더해가며 키움
            - 데이터 손실 발생시 혼자 윈도의 크기를 곱 감소 (multiplicative decrease) 방식을 적용해 1/2배와 같이 배수 단위로 줄임
            - 장점: 시간이 지나면 여러 송신부 간에 네트워크 대역폭을 공평하게 사용할 수 있음
            - 단점: 데이터 유실 발생시 윈도우 크기 증가폭 대비 윈도우 크기 감소폭이 크기 때문에 네트워크의 대역폭을 넓게 사용하기까지 시간이 오래 걸림
        - 느린 시작 (slow start)
            - 윈도우 크기가 1인 상태에서 시작해 ACK 메시지를 수신할 때마다 윈도우 크기를 1씩 늘려나가다가 혼잡 발생시 윈도우 크기를 1로 확 줄이는 방식
            - ex) 송신부가 수신부로부터 패킷 1개에 대한 ACK 메시지 수신시 다음에 패킷 2개 전송 가능 → 패킷 2개 보내고 각 패킷에 대한 ACK 메시지 수신시 패킷 4개 전송 가능 ⇒ 전송 가능한 패킷 수가 지수 함수 형태로 증가
            - 패킷을 1개부터 점차 늘려나감
            - 초기에 전송 가능한 패킷 수가 적은 AIMD 방식의 단점 보완
        - 혼잡 회피 (congestion avoidance)
            - 윈도우 크기가 지수 함수 형태로 증가하다가 혼잡이 발생하는 것을 방지하기 위해 윈도우 크기에 대한 임계점을 정하는 방식
            - 윈도우 크기 임계점 도달시 위녿우 크기를 선형적으로 증가하게 함
            - ACK 메시지 받지 못해 타임아웃 발생시 그 시점에서 윈도우 크기의 절반을 임계점으로 설정 후 윈도우 크기를 초깃값으로 변경
        - 빠른 회복 (fast recovery)
            - 혼잡 발생시 혼잡 윈도우 크기를 절반으로 줄인 후 선형적으로 증가하는 방식
            - 첫 혼잡 발생시 AIMD 방식으로 동작하는 것과 같음
        - 빠른 재전송 (fast retransmit)
            - Duplicate ACK가 3번 발생시 (3 Duplicate ACK) 해당 시점의 윈도우 크기를 1/2로 줄이고, 그 뒤로 ACK 메시지를 받으면 다시 윈도우 크기를 키우는 방식
                - Duplicate ACK : 패킷이 순서대로 도착하지 않아서 받아야 할 차례의 패킷을  ACK 메시지와 함께 요청하는 것
                    - 3번 발생시 혼잡 발생이라 판단
        - 혼합 제어 정책
            - TCP Tahoe, TCP Reno
                - 느린 시작 방식을 사용하다 임계점을 넘어가며 AIMD 바식으로 전환함
- **오류 제어**
    - **통신 중 데이터에 오류 또는 유실이 발생**할 때 데이터의 신뢰성을 보장하기 위해 오류를 제어하는 방식
    - 데이터에 오류 또는 유실 발생을 인지하는 경우
        - 수신부에서 잘못된 데이터를 받았다는 응답인 NAK (Negative Acknowledge) 메시지를 보낸 경우
        - 3 Duplicate ACK가 발생할 때
        - 수신부로부터 ACK 메시지를 받지 못해 타임아웃이 발생할 때
    - 데이터 오류 또는 유실 발생시 제어 방식
        - 정지-대기
            - 송신한 패킷에 대한 ACK 메시지를 일정시간 동안 받지 못해 타임아웃 발생시 해당 패킷을 다시 보내는 방식
            - 송신부에서 데이터를 1개만 보내고 메시지를 기다려야 하기 때문에 ARQ 방식이 사용됨
                - ARQ (Automatic Repeat Request) : 재전송 요청
        - Go-Back-N ARQ
            - 송신부에서 연속적으로 데이터를 보냈을 때 누락된 데이터 존재시 송신부에서 해당 데이터부터 재전송하는 방식
                - 송신부가 패킷 0 ~ 2 전송시 ACK 3 메시지 수신 → 다음에 패킷 3부터 전송
                - 송신부가 패킷 3 ~ 5 전송시 ACK 4 메시지 수신 → 패킷 4, 5  재전송
        - Selective-Repeat ARQ
            - 송신부에서 연속적으로 데이터 보냈을 때 누락된 데이터 존재시 수신부에서 해당 데이터만 재전송 요청하는 방식
            - 받은 패킷 재정렬하는 로직이 추가적으로 필요

### (4) UDP

- UDP (User Datagram Protocol, 사용자 데이터그램 프로토콜)
- TCP와 마찬가지로 전송계층에 해당하는 네트워크 프로토콜
- TCP와 달리 3-way 핸드셰이킹 같은 과정 없이 패킷 바로 송수신
    - 신뢰성 낮지만 속도 빠름
- 특징
    - 송신부와 수신부의 연결이 보장되지 않는 비연결형 서비스
    - 패킷이 서로 다른 회선으로 교환될 수 있는 데이터그램 패킷 교환 방식
    - 송신부에서 전달한 패킷 순서와 수신부에서 받은 패킷 순서가 다를 수 있음
    - 패킷의 수신 여부를 확인하지 않음
    - 1:1 통신, 1:N 통신, N:N 통신 모두 가능
    - 데이터의 신뢰성이 낮음
    - 데이터의 전송 속도가 빠름

### (5) UDP의 오류 검출

- 체크섬(checksum) 방식으로 오류 검출
    - 최소한의 신뢰성 보장 목적
    - 데이터의 무결성 보장하는 간단한 방법
    - 체크섬을 만들기 위한 데이터를 모두 더하는데 이때 오버플로되는 캐리가 발생하면 해당 캐리를 떼서 데이터에 다시 더한 후 1의 보수를 취해 체크섬을 만듦
        - 캐리: 2진수 덧셈 연산 시 자릿수가 넘어가는 (오버플로) 것
        - 1의 보수: 각 자릿수의 값이 모두 1인 수에서 주어진 2진수를 빼면 나오는 수
1. UDP 송신부
    1. UDP의 헤더, IP헤더의 일부 정보와 데이터로 체크섬값 생성
        - IP헤더의 일부 정보: 발신 IP 주소, 수신 IP 주소, 프로토콜 ID 등
    2. 생성한 체크섬 값을 UDP 헤더의 체크섬 영역에 넣어서 수신부에 보냄
2. UDP 수신부
    1. 체크섬을 포함한 모든 값을 더해 비트가 모두 1이 나오는지 확인
        - 비트가 모두 1 = 송신부와 동일한 체크섬 값이 나온다는 것
- 체크섬 100% 오류 검출 불가능
    - 데이터의 순서 변경 or 오류 발생시에도 체크섬 값 같은 경우 존재
    - UDP의 체크섬 = 선택사항
        - 송신부에서 체크섬 값 0으로 전송시 수신부는 체크섬 계산 X

---

## 3. HTTP

### (1) HTTP

- HyperText Transfer Protocol
- 인터넷 상에서 데이터를 전송하기 위한 프로토콜
- TCP/IP 4계층에서 응용 계층에 속함
- 특징
    1. **비연결성**
        - 클라이언트에서 요청을 보낸 후 서버로부터 응답을 받으면 연결을 끊는 것
        - 장점: 불특정 다수를 대상으로 하는 서비스에 유리 (자원 절약)
        - 단점: 서버가 클라이언트를 기억할 수 없고, 동일한 클라이언트의 연속적이 요청시 연결과 해제 과정 반복하게 되어 자원 낭비함
            - HTTP Keep Alive가 보완
                - 일정 시간 동안 연결 유지할 수 있도록 하는 HTTP 헤더의 일종
                    - 클라이언트에서 HTTP 요청 전송시 연결 헤더에 Keep Alive 추가 후 전송 → 서버에서 연결을 유지할 시간을 Keep Alive 헤더에 추가하여 응답
                - 마지막 응답 이후 일정 시간 동안 연결을 유지해 동일한 클라이언트로부터의 요청시 연결 과정 생략
    2. **무상태**
        - 서버에서 클라이언트의 상태를 저장하지 않는 것
        - 이전에 클라이언트가 요청한 사항을 서버에 저장하지 않음
            
            ⇒ 클라이언트가 요청에 필요한 데이터 모두 가지고 있거나 서버가 클라이언트로부터 받은 요청 사항을 모두 저장해야 함
            
            - 이 방법들을 `쿠키`와 `세션`이라고 함
            - 쿠키: 클라이언트의 로컬 웹 브라우저에 저장하는 데이터 파일 (ex. 웹사이트 로그인 정보, 쇼핑몰의 장바구니)
            - 세션: 서버에서 클라이언트와의 연결 정보를 저장 및 관리하는 것, 보안 면에서 쿠기보다 좋지만 접속자가 많을 경우 서버에 과부하가 올 수 있음
        - 장점: 서버 확장성이 높음
            - 클라이언트의 요청에 응답하는 서버가 바뀌어도 되므로 서버 계속 확장 가능
            - 특정 서버에 문제 생겨 응답하지 못하는 문제점 보완
    - HTTP 메시지
        - 클라이언트와 서버가 통신하기 위해서 HTTP에서 주고 받는 정향화된 데이터
        - 구조
            - 클라이언트의 요청 메시지
                - 요청라인, 헤더, 빈 줄, 바디
            - 서버의 응답 메시지
                - 상태 또는 응답 라인, 헤더, 빈 줄, 바디
            - 설명
                - 요청 라인: 요청 URI, 요청 방법, HTTP 버전 등을 포함
                - 상태 라인: 요청에 대한 HTTP 상태 코드와 HTTP 버전을 포함함
                - 헤더: 키-값으로 구성된 다수의 헤더 항목으로 구성됨
                - 빈 줄: 헤더의 끝을 나타내는 빈 줄로, 헤더와 바디를 구분함
                - 바디: 요청할 때 요청 방법 메서드가 POST인 경우에만 바디가 있고, 그 외 메서드일 때는 비어 있는 상태로 전달함
        - HTTP 상태 코드
            - 클라이언트의 요청에 대한 서버의 상태를 알려 주는 코드로, 세 자리 숫자로 표현함
                - 1xx : 클라이언트로부터 요청을 받아 처리 중
                - 2xx : 요청을 성공적으로 처리함
                    - 200: 클라이언트 요청을 성공적으로 처리함
                - 3xx : 요청을 처리하기 위해 추가 처리 필요
                - 4xx : 클라이언트 오류
                    - 401: 인증되지 않음
                    - 403: 접근 실패
                    - 404: 클라이언트에서 요청한 자원을 찾지 못함
                - 5xx : 서버 오류
                    - 500: 서버 내부 오류 발생

### (2) HTTPS

- HyperText Transfer Protocol Secure
- 보안 계층인 SSL/TLS를 이용해 HTTP의 보안을 강화한 웹 통신 프로토콜
    - HTTP: 데이터 암호화 거치지 않고 전송 → 보안 취약
    - SSL (Secure Socket Layer): 넷스케이프에서 개발한 암호화 프로토콜
    - TLS (Transport Layer Security): SSL의 문제점을 보완해 만들어진 암호환 프로토콜
        - 현재 HTTPS에서 통용되는 방식
    - 암호화 방식
        - 대칭키 암호화 방식
            - 데이터의 암호화와 복호화에 모두 같은 키인 대칭 키를 이용하는 방식
        - 공개키 암호화 방식
            - 데이터의 암호화와 복호화를 다른 키로 하는 방식
            - 데이터 암호화시 공개키, 데이터 복호화시 비밀키 이용
            1. 수신자는 공개키를 송신자에게 줌 (수신자의 공개 키는 모든 송신자에게 같음)
            2. 송신자는 수신자에게 받은 키로 데이터를 암호화 함
            3. 수신자는 비밀 키로 송신자에게 받은 데이터를 복호화함
            
            ⇒ 비밀 키가 있어야만 데이터 복호화 가능 → 공개 키 유출 염려 X
            
- 동작 방식
    1. **데이터 송신**시 `응용 계층`에서 `보안 계층`의 SSL/TLS로 데이터 보냄
    2. 데이터를 암호화해 `전송 계층`으로 전달
    3. **데이터 수신**시 `전송 계층`에서 보낸 데이터를 `보안 계층`의 SSL/TLS에서 받음 
    4. 데이터 복호화한 후 `응용 계층`으로 보냄

### (3) 웹페이지 접속 과정

1. 사용자가 URL을 웹 브라우저에 입력함
2. 웹브라우저는 입력한 URL을 바탕으로 DNS (Domain Name System) 서버에 연결할 IP를 요청함
3. DNS 서버는 IP 주소를 웹 브라우저에게 응답으로 제공함
4. 웹 브라우저는 DNS 서버에서 받은 IP를 통해 웹 서버와 TCP/IP 연결을 하고 HTTP 요청을 보냄
5. 웹 서버는 받은 HTTP 요청에 응답함
    1. 응답은 웹 페이지와 필요한 리소스를 포함함
6. 웹 브라우저는 받은 응답을 바탕으로 사용자에게 웹 페이지를 보여줌

---

## 4. REST

- HTTP 통신을 쉽게 활용할 수 있는 대표적인 방법
- HTTP를 기반으로 한 플랫폼에서 범용으로 사용됨

### (1) REST란?

- HTTP 통신을 활용하기 위해 고안된 아키텍처
- Representational State Transfer
    - Representational: 인터넷상의 자원을 URI로 나타낼 수 있음을 의미함
        - 클라이언트는 URI로 표현된 자원을 HTTP 메서드를 이용해 CRUD 연산을 할 수 있음
    - State Transfer: 자원의 상태를 주고 받는 것
        - 요청받은 자원의 상태를 전달하는 것
- 자원을 명시해 연산을 수행하고 상태를 주고 받는 것
- 특징
    - 일관된 인터페이스
        - 자원을 나타내는 URI를 HTTP 메서드로 조작하는 일관된 인터페이스 사용
        - HTTP를 따르는 모든 플랫폼에서 REST를 사용할 수 있음
    - 클라이언트-서버 구조
        - 클라이언트와 서버 간에 요청-응답의 독립적인 구조를 가짐
        - 클라이언트는 서버에 요청을 보내고 응답을 대기함
        - 서버는 자원을 가지고 있으며 클라이언트의 요청에 응답함
    - 무상태성
        - 서버에서는 클라이언트의 요청을 저장하거나 관리하지 ㅇ낳음
        - 서버는 클라이언트의 요청에 대한 처리와 응답만함
        - 사용자 인증, 로그인 정보 등은 클라이언트에서 직접 관리함
    - 캐싱 가능
        - HTTP 표준을 사용하므로 클라이언트는 이전에 서버로부터 받은 응답을 저장 및 재사용하는 캐싱을 할 수 있음
        - 클라이언트의 많은 요청으로부터 서버 부하를 줄여 주고, 클라인언트는 비교적 빨리 응답을 받을 수 있게 함
    - 자체 표현 구조
        - REST API는 자원, 행위, 표현으로 구성되어 REST API 메시지를 보고 어떤 요청을 하는지 알 수 있음
    - 계층형 구조
        - REST 서버는 다중 계층으로 구성될 수 있어서, 암호화와 같은 계층을 추가해 서버에 대한 기능을 유연하게 확장할 수 있음
- 장점: 별도의 인프라를 구축할 필요가 없음 → HTTP 표준 따르면 REST 쉽게 사용 가능
- 단점: HTTP 메서드를 사용해 자원에 대한 연산을 처리하므로 동작이 한정적임
- 추가 개념
    - URI (Uniform Resource Identifier) : 인터넷에 있는 자원을 나타내는 구조
    - URL (Uniform Resource Locator) : 인터넷에서 자원의 위치를 알 수 있는 규약
    - URN (Uniform Resource Name) : 자원의 위치 정보가 아닌 실제 자원을 특정함

### (2) REST API

- REST를 기반으로 한 API (Application Programming Interface)
    - API: 다른 소프트웨어에 서비스를 제공하기 위한 소프트웨어 인터페이스
- 구성
    - 자원 (자원의 식별 = URI)
    - 행위 (자원에 대한 행위 = HTTP 메서드)
    - 표현 (전달되는 데이터 표현 = JSON, XML)
- 작동 방식
    1. 클라이언트가 URI로 식별한 자원에 대해 HTTP 메서드를 사용해 REST API로 요청함
    2. REST API가 HTTP 요청 메시지에 실려 서버에 전달됨
    3. 서버에서는 수신한 HTTP 요청 메시지를 바탕으로 요청 사항을 확인해 처리하고 HTTP 응답을 반환함
        1. 요청에 대한 처리 성공 여부와 정보 포함
    4. 응답 메시지는 자원에 대한 정보를 JSON 또는 XML 등의 형태로 포함하고 있음
        1. 클라이언트는 해당 행태의 정보를 수신함
- RESTful한 서비스: REST 규칙을 지키며 API를 제공하는 서비스
    - 규칙
        - 자원에 대한 행위는 HTTP 메서드로 나타내며, HTTP 메서드나 행위에 대한 표현이 URI에 들어가면 안 됨
    - HTTP 메서드는 명시적이어야 함 (요청하려는 목적에 맞게 HTTP 메서드 사용)
    - URI 경로는 슬래시로 계층 관계를 표현하며, URI 마지막에 슬래시가 들어가면 안 됨
    - URI 경로에는 언더바를 사용하면 안 되고, 소문자 사용을 지향함

### (3) HTTP 메서드

- 클라이언트가 요청을 보낼 때 요청에 포함된 HTTP 메서드
    - POST: 데이터 생성시 사용 (C)
    - GET: 데이터 조회시 사용 (R)
    - PUT: 데이터 갱신시 사용 (U)
    - DELETE: 데이터 제거시 사용 (D)
    - PATCH: 데이터 일부를 갱신할 때 사용
    - HEAD: GET과 동일하게 데이터를 조회활 때 사용하지만, HTTP 메시지에 바디를 포함하지 않고 헤더로만 응답함
    - TRACE: 클라이언트의 요청 메시지를 그대로 반환(루프백 메시지)하면서 쿠키 및 세션 값을 포함해 응답
    - CONNECT: 요청한 자원을 양방향으로 연결하는 데 사용함
        - SSL을 사용하는 웹사이트에 접속 가능
    - OPTION: 서버가 지원하는 HTTP 메서드를 메시지 헤더에 포함해 응답
